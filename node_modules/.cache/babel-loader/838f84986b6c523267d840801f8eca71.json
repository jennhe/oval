{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nvar defaultEncodeOptions = {\n  float64: false,\n  mapSorter: mapSorter,\n  quickEncodeToken: quickEncodeToken\n};\nvar cborEncoders = [];\ncborEncoders[Type.uint.major] = encodeUint;\ncborEncoders[Type.negint.major] = encodeNegint;\ncborEncoders[Type.bytes.major] = encodeBytes;\ncborEncoders[Type.string.major] = encodeString;\ncborEncoders[Type.array.major] = encodeArray;\ncborEncoders[Type.map.major] = encodeMap;\ncborEncoders[Type.tag.major] = encodeTag;\ncborEncoders[Type.float.major] = encodeFloat;\nvar buf = new Bl();\n\nvar Ref = /*#__PURE__*/function () {\n  function Ref(obj, parent) {\n    _classCallCheck(this, Ref);\n\n    this.obj = obj;\n    this.parent = parent;\n  }\n\n  _createClass(Ref, [{\n    key: \"includes\",\n    value: function includes(obj) {\n      var p = this;\n\n      do {\n        if (p.obj === obj) {\n          return true;\n        }\n      } while (p = p.parent);\n\n      return false;\n    }\n  }], [{\n    key: \"createCheck\",\n    value: function createCheck(stack, obj) {\n      if (stack && stack.includes(obj)) {\n        throw new Error(\"\".concat(encodeErrPrefix, \" object contains circular references\"));\n      }\n\n      return new Ref(obj, stack);\n    }\n  }]);\n\n  return Ref;\n}();\n\nvar simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nvar typeEncoders = {\n  number: function number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint: function bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array: function Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string: function string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean: function boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null: function _null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined: function undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer: function ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView: function DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array: function Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n\n      return simpleTokens.emptyArray;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    var entries = [];\n    var i = 0;\n\n    var _iterator = _createForOfIteratorHelper(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        entries[i++] = objectToTokens(e, options, refStack);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n\n    return [new Token(Type.array, obj.length), entries];\n  },\n  Object: function (_Object) {\n    function Object(_x, _x2, _x3, _x4) {\n      return _Object.apply(this, arguments);\n    }\n\n    Object.toString = function () {\n      return _Object.toString();\n    };\n\n    return Object;\n  }(function (obj, typ, options, refStack) {\n    var isMap = typ !== 'Object';\n    var keys = isMap ? obj.keys() : Object.keys(obj);\n    var length = isMap ? obj.size : keys.length;\n\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n\n      return simpleTokens.emptyMap;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    var entries = [];\n    var i = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(keys),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var key = _step2.value;\n        entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    sortMapEntries(entries, options);\n\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n\n    return [new Token(Type.map, length), entries];\n  })\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\n\nvar _iterator3 = _createForOfIteratorHelper('Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')),\n    _step3;\n\ntry {\n  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n    var typ = _step3.value;\n    typeEncoders[\"\".concat(typ, \"Array\")] = typeEncoders.DataView;\n  }\n} catch (err) {\n  _iterator3.e(err);\n} finally {\n  _iterator3.f();\n}\n\nfunction objectToTokens(obj) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var refStack = arguments.length > 2 ? arguments[2] : undefined;\n  var typ = is(obj);\n  var customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n\n  if (typeof customTypeEncoder === 'function') {\n    var tokens = customTypeEncoder(obj, typ, options, refStack);\n\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n\n  var typeEncoder = typeEncoders[typ];\n\n  if (!typeEncoder) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: \").concat(typ));\n  }\n\n  return typeEncoder(obj, typ, options, refStack);\n}\n\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\n\nfunction mapSorter(e1, e2) {\n  var keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  var keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n\n  var major = keyToken1.type.major;\n  var tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n\n  return tcmp;\n}\n\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    var _iterator4 = _createForOfIteratorHelper(tokens),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var token = _step4.value;\n        tokensToEncoded(buf, token, encoders, options);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\n\nfunction encodeCustom(data, encoders, options) {\n  var tokens = objectToTokens(data, options);\n\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    var quickBytes = options.quickEncodeToken(tokens);\n\n    if (quickBytes) {\n      return quickBytes;\n    }\n\n    var encoder = encoders[tokens.type.major];\n\n    if (encoder.encodedSize) {\n      var size = encoder.encodedSize(tokens, options);\n\n      var _buf = new Bl(size);\n\n      encoder(_buf, tokens, options);\n\n      if (_buf.chunks.length !== 1) {\n        throw new Error(\"Unexpected error: pre-calculated length for \".concat(tokens, \" was wrong\"));\n      }\n\n      return asU8A(_buf.chunks[0]);\n    }\n  }\n\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"sources":["/Users/jenniferhe/Documents/GitHub/oval/node_modules/cborg/esm/lib/encode.js"],"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","cborEncoders","uint","major","negint","bytes","string","array","map","tag","float","buf","Ref","obj","parent","p","stack","includes","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","createCheck","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","encoders","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","toBytes","encode","assign"],"mappings":"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","sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nconst cborEncoders = [];\ncborEncoders[Type.uint.major] = encodeUint;\ncborEncoders[Type.negint.major] = encodeNegint;\ncborEncoders[Type.bytes.major] = encodeBytes;\ncborEncoders[Type.string.major] = encodeString;\ncborEncoders[Type.array.major] = encodeArray;\ncborEncoders[Type.map.major] = encodeMap;\ncborEncoders[Type.tag.major] = encodeTag;\ncborEncoders[Type.float.major] = encodeFloat;\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"]},"metadata":{},"sourceType":"module"}