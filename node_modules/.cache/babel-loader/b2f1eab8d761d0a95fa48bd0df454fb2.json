{"ast":null,"code":"import _classCallCheck from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport { asU8A, fromString } from '../byte-utils.js';\n\nvar JSONEncoder = /*#__PURE__*/function (_Array, _Type$uint$major, _Type$negint$major, _Type$bytes$major, _Type$string$major, _Type$array$major, _Type$map$major, _Type$tag$major, _Type$float$major) {\n  _inherits(JSONEncoder, _Array);\n\n  var _super = _createSuper(JSONEncoder);\n\n  function JSONEncoder() {\n    var _this;\n\n    _classCallCheck(this, JSONEncoder);\n\n    _this = _super.call(this);\n    _this.inRecursive = [];\n    return _this;\n  }\n\n  _createClass(JSONEncoder, [{\n    key: \"prefix\",\n    value: function prefix(buf) {\n      var recurs = this.inRecursive[this.inRecursive.length - 1];\n\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          recurs.elements++;\n\n          if (recurs.elements !== 1) {\n            buf.push([44]);\n          }\n        }\n\n        if (recurs.type === Type.map) {\n          recurs.elements++;\n\n          if (recurs.elements !== 1) {\n            if (recurs.elements % 2 === 1) {\n              buf.push([44]);\n            } else {\n              buf.push([58]);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: _Type$uint$major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var is = String(token.value);\n      var isa = [];\n\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n      }\n\n      buf.push(isa);\n    }\n  }, {\n    key: _Type$negint$major,\n    value: function value(buf, token) {\n      this[Type.uint.major](buf, token);\n    }\n  }, {\n    key: _Type$bytes$major,\n    value: function value(_buf, _token) {\n      throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: Uint8Array\"));\n    }\n  }, {\n    key: _Type$string$major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var byts = fromString(JSON.stringify(token.value));\n      buf.push(byts.length > 32 ? asU8A(byts) : byts);\n    }\n  }, {\n    key: _Type$array$major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: Type.array,\n        elements: 0\n      });\n      buf.push([91]);\n    }\n  }, {\n    key: _Type$map$major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: Type.map,\n        elements: 0\n      });\n      buf.push([123]);\n    }\n  }, {\n    key: _Type$tag$major,\n    value: function value(_buf, _token) {}\n  }, {\n    key: _Type$float$major,\n    value: function value(buf, token) {\n      if (token.type.name === 'break') {\n        var recurs = this.inRecursive.pop();\n\n        if (recurs) {\n          if (recurs.type === Type.array) {\n            buf.push([93]);\n          } else if (recurs.type === Type.map) {\n            buf.push([125]);\n          } else {\n            throw new Error('Unexpected recursive type; this should not happen!');\n          }\n\n          return;\n        }\n\n        throw new Error('Unexpected break; this should not happen!');\n      }\n\n      if (token.value === undefined) {\n        throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: undefined\"));\n      }\n\n      this.prefix(buf);\n\n      if (token.type.name === 'true') {\n        buf.push([116, 114, 117, 101]);\n        return;\n      } else if (token.type.name === 'false') {\n        buf.push([102, 97, 108, 115, 101]);\n        return;\n      } else if (token.type.name === 'null') {\n        buf.push([110, 117, 108, 108]);\n        return;\n      }\n\n      var is = String(token.value);\n      var isa = [];\n      var dp = false;\n\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n\n        if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n          dp = true;\n        }\n      }\n\n      if (!dp) {\n        isa.push(46);\n        isa.push(48);\n      }\n\n      buf.push(isa);\n    }\n  }]);\n\n  return JSONEncoder;\n}( /*#__PURE__*/_wrapNativeSuper(Array), Type.uint.major, Type.negint.major, Type.bytes.major, Type.string.major, Type.array.major, Type.map.major, Type.tag.major, Type.float.major);\n\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" complex map keys are not supported\"));\n  }\n\n  var keyToken1 = e1[0];\n  var keyToken2 = e2[0];\n\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" non-string map keys are not supported\"));\n  }\n\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n\n  throw new Error(\"\".concat(encodeErrPrefix, \" unexpected duplicate map keys, this is not supported\"));\n}\n\nvar defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter: mapSorter\n};\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\n\nexport { encode };","map":{"version":3,"sources":["/Users/jenniferhe/Documents/GitHub/oval/node_modules/cborg/esm/lib/json/encode.js"],"names":["Type","encodeCustom","encodeErrPrefix","asU8A","fromString","JSONEncoder","inRecursive","buf","recurs","length","type","array","elements","push","map","token","prefix","is","String","value","isa","i","charCodeAt","uint","major","_buf","_token","Error","byts","JSON","stringify","name","pop","undefined","dp","Array","negint","bytes","string","tag","float","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","Object","assign"],"mappings":"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","sourcesContent":["import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport {\n  asU8A,\n  fromString\n} from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {\n  }\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${ encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${ encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport {\n  encode\n};"]},"metadata":{},"sourceType":"module"}