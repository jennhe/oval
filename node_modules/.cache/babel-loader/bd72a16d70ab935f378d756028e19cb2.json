{"ast":null,"code":"import _classCallCheck from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/jenniferhe/Documents/GitHub/oval/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\nimport { Token, Type } from 'cborg';\nimport * as cborgJson from 'cborg/json';\n\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n\n  var cid = CID.asCID(obj);\n\n  if (!cid) {\n    return null;\n  }\n\n  var cidString = cid.toString();\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), new Token(Type.string, cidString, cidString.length), new Token(Type.break, undefined, 1)];\n}\n\nfunction bytesEncoder(bytes) {\n  var bytesString = base64.encode(bytes).slice(1);\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), new Token(Type.map, Infinity, 1), new Token(Type.string, 'bytes', 5), new Token(Type.string, bytesString, bytesString.length), new Token(Type.break, undefined, 1), new Token(Type.break, undefined, 1)];\n}\n\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  return null;\n}\n\nvar encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder,\n    Buffer: bytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n\nvar DagJsonTokenizer = /*#__PURE__*/function (_cborgJson$Tokenizer) {\n  _inherits(DagJsonTokenizer, _cborgJson$Tokenizer);\n\n  var _super = _createSuper(DagJsonTokenizer);\n\n  function DagJsonTokenizer(data, options) {\n    var _this;\n\n    _classCallCheck(this, DagJsonTokenizer);\n\n    _this = _super.call(this, data, options);\n    _this.tokenBuffer = [];\n    return _this;\n  }\n\n  _createClass(DagJsonTokenizer, [{\n    key: \"done\",\n    value: function done() {\n      return this.tokenBuffer.length === 0 && _get(_getPrototypeOf(DagJsonTokenizer.prototype), \"done\", this).call(this);\n    }\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      if (this.tokenBuffer.length > 0) {\n        return this.tokenBuffer.pop();\n      }\n\n      return _get(_getPrototypeOf(DagJsonTokenizer.prototype), \"next\", this).call(this);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var token = this._next();\n\n      if (token.type === Type.map) {\n        var keyToken = this._next();\n\n        if (keyToken.type === Type.string && keyToken.value === '/') {\n          var valueToken = this._next();\n\n          if (valueToken.type === Type.string) {\n            var breakToken = this._next();\n\n            if (breakToken.type !== Type.break) {\n              throw new Error('Invalid encoded CID form');\n            }\n\n            this.tokenBuffer.push(valueToken);\n            return new Token(Type.tag, 42, 0);\n          }\n\n          if (valueToken.type === Type.map) {\n            var innerKeyToken = this._next();\n\n            if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n              var innerValueToken = this._next();\n\n              if (innerValueToken.type === Type.string) {\n                for (var i = 0; i < 2; i++) {\n                  var _breakToken = this._next();\n\n                  if (_breakToken.type !== Type.break) {\n                    throw new Error('Invalid encoded Bytes form');\n                  }\n                }\n\n                var bytes = base64.decode(\"m\".concat(innerValueToken.value));\n                return new Token(Type.bytes, bytes, innerValueToken.value.length);\n              }\n\n              this.tokenBuffer.push(innerValueToken);\n            }\n\n            this.tokenBuffer.push(innerKeyToken);\n          }\n\n          this.tokenBuffer.push(valueToken);\n        }\n\n        this.tokenBuffer.push(keyToken);\n      }\n\n      return token;\n    }\n  }]);\n\n  return DagJsonTokenizer;\n}(cborgJson.Tokenizer);\n\nvar decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[42] = CID.parse;\nexport var name = 'dag-json';\nexport var code = 297;\nexport var encode = function encode(node) {\n  return cborgJson.encode(node, encodeOptions);\n};\nexport var decode = function decode(data) {\n  var options = Object.assign(decodeOptions, {\n    tokenizer: new DagJsonTokenizer(data, decodeOptions)\n  });\n  return cborgJson.decode(data, options);\n};","map":{"version":3,"sources":["/Users/jenniferhe/Documents/GitHub/oval/node_modules/@ipld/dag-json/esm/index.js"],"names":["CID","base64","Token","Type","cborgJson","cidEncoder","obj","asCID","cid","cidString","toString","map","Infinity","string","length","break","undefined","bytesEncoder","bytes","bytesString","encode","slice","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","encodeOptions","typeEncoders","Object","Uint8Array","Buffer","number","DagJsonTokenizer","data","options","tokenBuffer","pop","token","_next","type","keyToken","value","valueToken","breakToken","push","tag","innerKeyToken","innerValueToken","i","decode","Tokenizer","decodeOptions","allowIndefinite","allowUndefined","allowNaN","allowInfinity","allowBigInt","strict","useMaps","tags","parse","name","code","node","assign","tokenizer"],"mappings":"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","sourcesContent":["import { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\nimport {\n  Token,\n  Type\n} from 'cborg';\nimport * as cborgJson from 'cborg/json';\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const cidString = cid.toString();\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1),\n    new Token(Type.string, cidString, cidString.length),\n    new Token(Type.break, undefined, 1)\n  ];\n}\nfunction bytesEncoder(bytes) {\n  const bytesString = base64.encode(bytes).slice(1);\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1),\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, 'bytes', 5),\n    new Token(Type.string, bytesString, bytesString.length),\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder,\n    Buffer: bytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  constructor(data, options) {\n    super(data, options);\n    this.tokenBuffer = [];\n  }\n  done() {\n    return this.tokenBuffer.length === 0 && super.done();\n  }\n  _next() {\n    if (this.tokenBuffer.length > 0) {\n      return this.tokenBuffer.pop();\n    }\n    return super.next();\n  }\n  next() {\n    const token = this._next();\n    if (token.type === Type.map) {\n      const keyToken = this._next();\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next();\n        if (valueToken.type === Type.string) {\n          const breakToken = this._next();\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form');\n          }\n          this.tokenBuffer.push(valueToken);\n          return new Token(Type.tag, 42, 0);\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next();\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next();\n            if (innerValueToken.type === Type.string) {\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next();\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form');\n                }\n              }\n              const bytes = base64.decode(`m${ innerValueToken.value }`);\n              return new Token(Type.bytes, bytes, innerValueToken.value.length);\n            }\n            this.tokenBuffer.push(innerValueToken);\n          }\n          this.tokenBuffer.push(innerKeyToken);\n        }\n        this.tokenBuffer.push(valueToken);\n      }\n      this.tokenBuffer.push(keyToken);\n    }\n    return token;\n  }\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[42] = CID.parse;\nexport const name = 'dag-json';\nexport const code = 297;\nexport const encode = node => cborgJson.encode(node, encodeOptions);\nexport const decode = data => {\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) });\n  return cborgJson.decode(data, options);\n};"]},"metadata":{},"sourceType":"module"}